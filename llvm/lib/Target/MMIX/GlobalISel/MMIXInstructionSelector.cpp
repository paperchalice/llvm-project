//===-- MMIXInstructionSelector.cpp -----------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the Global InstructionSelector class
/// for MMIX. \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "MMIXInstructionSelector.h"
#include "MMIXInstrInfo.h"
#include "MMIXRegisterBankInfo.h"
#include "MMIXSubtarget.h"
#include "MMIXTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"

#define DEBUG_TYPE "mmix-isel"
namespace {
#define GET_GLOBALISEL_PREDICATE_BITSET
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET
} // namespace

namespace llvm {
class MMIXInstructionSelector : public InstructionSelector {
public:
  MMIXInstructionSelector(const MMIXTargetMachine &TM, const MMIXSubtarget &STI,
                          const MMIXRegisterBankInfo &RBI);
  static const char *getName();
  bool select(MachineInstr &I) override;

private:
  void constrainGenericOp(MachineInstr &MI) const;
  void constrainOperandRegClass(MachineOperand &RegMO,
                                const TargetRegisterClass &RegClass) const;
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  /// @brief select G_CONSTANT to sequence of SETx.
  /// This function convert
  /// ```G_CONSTANT i64 X``` ->
  /// %0:gpr = IMPLICIT_DEF
  /// %1:gpr = SETH %0, X[48..63]
  /// %2:gpr = ORMH %1, X[32...47]
  /// %3:gpr = ORML %2, X[16...31]
  /// %4:gpr = ORL %3, X[0...15]
  /// @param I
  /// @return true if succcess
  bool selectG_CONSTANT(MachineInstr &I) const;

  const MMIXSubtarget &STI;
  const MMIXInstrInfo &TII;
  const MMIXRegisterInfo &TRI;
  const MMIXRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // namespace llvm

using namespace llvm;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_IMPL
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

#define GET_InstEnc_DECL
#include "MMIXGenSearchableTables.inc"

static unsigned GetInstValue(unsigned Op) {
  switch (Op) {
  case InstEnc::SETH:
    return MMIX::SETH;
  case InstEnc::SETMH:
    return MMIX::SETMH;
  case InstEnc::SETML:
    return MMIX::SETML;
  case InstEnc::SETL:
    return MMIX::SETL;
  case InstEnc::ORH:
    return MMIX::ORH;
  case InstEnc::ORMH:
    return MMIX::ORMH;
  case InstEnc::ORML:
    return MMIX::ORML;
  case InstEnc::ORL:
    return MMIX::ORL;
  default:
    return 0;
  }
}

const char *MMIXInstructionSelector::getName() { return DEBUG_TYPE; }

MMIXInstructionSelector::MMIXInstructionSelector(
    const MMIXTargetMachine &TM, const MMIXSubtarget &STI,
    const MMIXRegisterBankInfo &RBI)
    : InstructionSelector(), STI(STI), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT

#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

void MMIXInstructionSelector::constrainGenericOp(MachineInstr &MI) const {
  MachineRegisterInfo &MRI = MI.getMF()->getRegInfo();
  for (MachineOperand &Op : MI.all_defs()) {
    if (Op.getReg().isPhysical() || MRI.getRegClassOrNull(Op.getReg()))
      continue;
    constrainOperandRegClass(Op, MMIX::GPRRegClass);
  }
}

void MMIXInstructionSelector::constrainOperandRegClass(
    MachineOperand &RegMO, const TargetRegisterClass &RegClass) const {
  MachineInstr &MI = *RegMO.getParent();
  MachineRegisterInfo &MRI = MI.getMF()->getRegInfo();
  RegMO.setReg(llvm::constrainOperandRegClass(*MF, TRI, MRI, TII, RBI, MI,
                                              RegClass, RegMO));
}

bool MMIXInstructionSelector::selectG_CONSTANT(MachineInstr &I) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && "not G_CONSTANT");

  MachineIRBuilder MIB(I);
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  LLVM_DEBUG(dbgs() << "selecting for instruction: ");
  LLVM_DEBUG(I.dump());
  auto Op = I.getOperand(1);
  std::uint64_t Val = 0;
  if (Op.isImm()) {
    Val = Op.getImm();
  } else {
    Val = Op.getCImm()->getZExtValue();
  }

  auto ImplicitReg = MRI.createVirtualRegister(&MMIX::GPRRegClass);
  BuildMI(MBB, I, I.getDebugLoc(), TII.get(MMIX::IMPLICIT_DEF))
      .addDef(ImplicitReg);
  auto SrcReg = ImplicitReg;
  for (int i = InstEnc::SETH; i <= InstEnc::ORL; ++i) {
    std::uint16_t Part = 0;
    switch (i & 0b0111) {
    case 0:
      Part = Val >> 48;
      break;
    case 1:
      Part = Val >> 32;
      break;
    case 2:
      Part = Val >> 16;
      break;
    case 3:
      Part = Val;
      break;
    }
    if (Part || i == InstEnc::SETL) {
      auto DstReg = MRI.createVirtualRegister(&MMIX::GPRRegClass);
      auto Instr =
          MIB.buildInstr(GetInstValue(i), {DstReg}, {SrcReg, Val & 0xFFFF});
      constrainSelectedInstRegOperands(*Instr, TII, TRI, RBI);
      assert(MRI.getRegClass(DstReg));
      SrcReg = DstReg;
      i |= InstEnc::ORH;
    }
  }

  // I don't know why can't replace all the usage
  constrainGenericOp(*MIB.buildCopy(I.getOperand(0).getReg(), SrcReg));
  I.eraseFromParent();
  return true;
}

bool MMIXInstructionSelector::select(MachineInstr &I) {
  LLVM_DEBUG(dbgs() << "select for instruction: ");
  LLVM_DEBUG(I.dump());

  // Ignore COPY's: the register allocator will handle them.
  if (!I.isPreISelOpcode()) {
    constrainGenericOp(I); // don't forget assign reg class for them
    return true;
  }

  // From SelectionDAG
  if (selectImpl(I, *CoverageInfo)) {
    return true;
  }

  using namespace MMIX;
  MachineIRBuilder MIB(I);

  switch (I.getOpcode()) {
  case G_CONSTANT:
    return selectG_CONSTANT(I);
  default:
    return true;
  }
}

InstructionSelector * ::llvm::createMMIXInstructionSelector(
    const MMIXTargetMachine &TM, MMIXSubtarget &STI,
    MMIXRegisterBankInfo &RBI) {
  return new MMIXInstructionSelector(TM, STI, RBI);
}
