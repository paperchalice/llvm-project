//===-- MMIXInstructionSelector.cpp -----------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the Global InstructionSelector class
/// for MMIX. \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "MMIXInstructionSelector.h"
#include "MMIXRegisterBankInfo.h"
#include "MMIXSubtarget.h"
#include "MMIXTargetMachine.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"

#define DEBUG_TYPE "mmix-isel"

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET
namespace llvm {
class MMIXInstructionSelector : public InstructionSelector {
public:
  MMIXInstructionSelector(const MMIXTargetMachine &TM, const MMIXSubtarget &STI,
                          const MMIXRegisterBankInfo &RBI);
  static const char *getName();
  bool select(MachineInstr &I) override;

private:
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  /// @brief select G_CONSTANT to sequence of SETx.
  /// This function convert
  /// ```G_CONSTANT i64 X``` ->
  /// %0:gpr = IMPLICIT_DEF
  /// %1:gpr = SETH %0, X[48..63]
  /// %2:gpr = SETMH %1, X[32...47]
  /// %3:gpr = SETML %2, X[16...31]
  /// %4:gpr = SETL %3, X[0...15]
  /// @param I
  /// @return true if succcess
  bool selectG_CONSTANT(MachineInstr &I) const;

  bool selectG_ADD(MachineInstr &I) const;

  const MMIXSubtarget &STI;
  const MMIXInstrInfo &TII;
  const MMIXRegisterInfo &TRI;
  const MMIXRegisterBankInfo &RBI;

#define GET_GLOBALISEL_PREDICATES_DECL
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL
};

} // namespace llvm

using namespace llvm;
using namespace MIPatternMatch;

#define GET_GLOBALISEL_IMPL
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

const char *MMIXInstructionSelector::getName() { return DEBUG_TYPE; }

MMIXInstructionSelector::MMIXInstructionSelector(
    const MMIXTargetMachine &TM, const MMIXSubtarget &STI,
    const MMIXRegisterBankInfo &RBI)
    : InstructionSelector(), STI(STI), TII(*STI.getInstrInfo()),
      TRI(*STI.getRegisterInfo()), RBI(RBI),

#define GET_GLOBALISEL_PREDICATES_INIT
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT

#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "MMIXGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

bool MMIXInstructionSelector::selectG_CONSTANT(MachineInstr &I) const {
  assert(I.getOpcode() == TargetOpcode::G_CONSTANT && "not G_CONSTANT");
  LLVM_DEBUG(dbgs() << "selecting for instruction: ");
  LLVM_DEBUG(I.dump());
  auto Op = I.getOperand(1);
  std::uint64_t Value = 0;
  if (Op.isImm()) {
    Value = Op.getImm();
  } else {
    Value = Op.getCImm()->getZExtValue();
  }
  MachineIRBuilder MIB(I);
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  auto ImplicitReg = MRI.createVirtualRegister(&MMIX::GPRRegClass);
  BuildMI(MBB, I, I.getDebugLoc(), TII.get(MMIX::IMPLICIT_DEF))
      .addDef(ImplicitReg);

  unsigned Ops[] = {MMIX::SETH, MMIX::SETMH, MMIX::SETML, MMIX::SETL};
  Register Regs[] = {ImplicitReg, MRI.createVirtualRegister(&MMIX::GPRRegClass),
                     MRI.createVirtualRegister(&MMIX::GPRRegClass),
                     MRI.createVirtualRegister(&MMIX::GPRRegClass),
                     I.getOperand(0).getReg()};
  for (int i = 0; i != 4; ++i) {
    std::uint64_t V = (Value >> (16 * (3 - i))) & 0xFFFF;
    auto Instr = MIB.buildInstr(Ops[i], {Regs[i + 1]}, {Regs[i], V});
    if (!constrainSelectedInstRegOperands(*Instr, TII, TRI, RBI)) {
      return false;
    }
  }
  I.eraseFromParent();
  return true;
}

bool MMIXInstructionSelector::selectG_ADD(MachineInstr &I) const {
  assert(I.getOpcode() == TargetOpcode::G_ADD && "not G_ADD");
  LLVM_DEBUG(dbgs() << "selecting for instruction: ");
  LLVM_DEBUG(I.dump());

  MachineIRBuilder MIB(I);
  MachineBasicBlock &MBB = *I.getParent();
  MachineFunction &MF = *MBB.getParent();
  MachineRegisterInfo &MRI = MF.getRegInfo();

  if (std::uint8_t ImmVal;
      mi_match(I, MRI, m_GAdd(m_Reg(), m_UI8Cst(ImmVal)))) {
    // select ADDI
    auto Instr = MIB.buildInstr(MMIX::ADDI, {I.getOperand(0)},
                                {I.getOperand(1), std::int64_t(ImmVal)});
    if (!constrainSelectedInstRegOperands(*Instr, TII, TRI, RBI)) {
      return false;
    }
    I.eraseFromParent();
    return true;
  }

  if (mi_match(I, MRI, m_GAdd(m_Reg(), m_Reg()))) {
    // select ADD
    auto Instr = MIB.buildInstr(MMIX::ADDI, {I.getOperand(0)},
                                {I.getOperand(1), I.getOperand(2)});
    if (!constrainSelectedInstRegOperands(*Instr, TII, TRI, RBI)) {
      return false;
    }
    I.eraseFromParent();
    return true;
  }

  return false;
}

bool MMIXInstructionSelector::select(MachineInstr &I) {
  LLVM_DEBUG(dbgs() << "select for instruction: ");
  LLVM_DEBUG(I.dump());

  // Ignore COPY's: the register allocator will handle them.
  if (!I.isPreISelOpcode()) {
    return true;
  }

  // From SelectionDAG
  if (selectImpl(I, *CoverageInfo)) {
    return true;
  }

  using namespace MMIX;
  MachineIRBuilder MIB(I);

  switch (I.getOpcode()) {
  case G_CONSTANT:
    return selectG_CONSTANT(I);
  case G_ADD: {
    return selectG_ADD(I);
  }
  default:
    return false;
  }
  return false;
}

InstructionSelector * ::llvm::createMMIXInstructionSelector(
    const MMIXTargetMachine &TM, MMIXSubtarget &STI,
    MMIXRegisterBankInfo &RBI) {
  return new MMIXInstructionSelector(TM, STI, RBI);
}
